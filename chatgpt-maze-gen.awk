# This script was generated by ChatGPT 4
#
# Q: Write AWK script to generate maze
# A: Here's an AWK script that generates a simple ASCII maze using Prim's algorithm:
# ...
# A: To run the script, save it to a file named maze.awk and then run the following command:
# awk -f maze.awk
# This script will generate a (25-1) x (25-1) cell maze with a starting point marked as "S"
# and an ending point marked as "E". Note that the width and height of the maze can be customized
# by changing the width and height variables.
#
# Keep in mind that AWK might not be the ideal tool for generating complex mazes due to
# the inherent limitations of the language. However, it can be a fun exercise to see
# what can be accomplished with AWK!
#
#
# Note: The script is not executable because of errors in syntaxs and cetera.
# However, it can give some ideas to develop your own solution.
#
BEGIN {
    srand()
    width = 25
    height = 25

    if (width % 2 == 0) width--
    if (height % 2 == 0) height--

    for (i = 1; i <= height; i++) {
        for (j = 1; j <= width; j++) {
            maze[i, j] = "#"
        }
    }

    startX = int(1 + rand() * (width - 1) / 2) * 2
    startY = int(1 + rand() * (height - 1) / 2) * 2
    maze[startY, startX] = "S"

    cell[i++] = startY SUBSEP startX

    while (i > 0) {
        index = int(rand() * i)
        split(cell[index], coords, SUBSEP)

        x = coords[2]
        y = coords[1]

        delete cell[index]
        cell[index] = cell[--i]

        # define possible neighbors
        neighbors = 0
        if (y > 2 && maze[y - 2, x] in maze) {
            y_arr[++neighbors] = y - 2
            x_arr[neighbors] = x
        }

        if (x < width - 1 && maze[y, x + 2] in maze) {
            y_arr[++neighbors] = y
            x_arr[neighbors] = x + 2
        }

        if (y < height - 1 && maze[y + 2, x] in maze) {
            y_arr[++neighbors] = y + 2
            x_arr[neighbors] = x
        }

        if (x > 2 && maze[y, x - 2] in maze) {
            y_arr[++neighbors] = y
            x_arr[neighbors] = x - 2
        }

        if (neighbors > 0) {
            cell[i++] = coords[1] SUBSEP coords[2]
            neighbor = 1 + int(rand() * neighbors)
            ny = y_arr[neighbor]
            nx = x_arr[neighbor]

            maze[(y + ny) / 2, (x + nx) / 2] = " "
            maze[ny, nx] = " "
            delete maze[ny, nx]

            cell[i++] = ny SUBSEP nx
        }
    }

    maze[startY, startX] = "S"
    maze[height, width] = "E"

    for (i = 1; i<= height; i++) {
        for (j = 1; j <= width; j++) {
            printf ("%s", maze[i, j])
        }
        printf ("\n")
    }
}
